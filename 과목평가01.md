

```python
입력과 출력이 뭔지 잘 짚어가면서 공부해야 한다. 
```

시퀀스 자료형의 특징이 아닌것은? 

1. 리스트 튜플 같은 자료형 타입이 있다
2. 순서대로 나열되어 있느 자료형이다
3. in 연산자로 자료형에 있는지 확인 가능
4. 사용자 임의대로 순서 변경 가능하다 x

result = 4+ 5+ True+ False 

= 10 

'#'


```python
word = 'python'
indexing = word[3:8]
print(indexing)

#

```

    hon
    


```python
names =['john','ron','james','betty']
print(names[-2][-2])

```

    e
    

다섯개의 정수 0을 가진 리스트를 만드는 방법 
1. l =[0,0,0,0,0]
2. l =[0]*5
3. l =[];l.append(0*5)  x
4. l =[0for range 5]
5. l =[];L.append(0*5)


```python
s= 'hello my name is ssapy'
for i in s:
    if i == "m":
        print(s)
```

    hello my name is ssapy
    hello my name is ssapy
    


```python
string = "i'm hungry"
result = ""

for idx,value in enumerate(string):
    if idx%2:
        result += value.upper()
    else:
        result += value
print(result)

#
```

    i'm hUnGrY
    

d1 = {'d':dict()}
d2 = dict(d={})

1. d1== d2는 false이다 
2. len(d2)는 1, len(d1)은 0이다
3. id(d1)== id(d2) 는 true
4. d1와 d2는 똑같이 빈 딕셔너리가 vaule다. o



```python
d = {'a':1,'b':2}
a1 = d.update(c=3)
a2 = a1 

print(a1)
#{'a':1,'b':2,'c':3}
# 원본을 바꾸는 아이들은 리턴값이 없다.

# 원본을 안바꾸는 아래는 출력이 나온다. 
print(sorted([4,3,2,1,]))

'''
len(a1)은 2이다. 
a1,a2는 같은 딕셔너리를 가리키고 있다.
오류가 뜬다.
보기중엔 답이 없다. o
'''


```

    None
    


```python
fruits = {'apple':'사과','banana':'바나나'}
a = fruits.get('apple')      #'사과' 출력
b = fruits.get('cherry')     #get은 없는 키면 None 출력한다. 
c = fruits.get('melon',True) #없으면 'True'가 나온다. 
d = {a:b}    #d = {'사과':None}
if c:        # True
    print(d) # d 출력
    
'''
1. 에러가 난다.
2. b는 none이다    o
3. 실행하면 아무것도 출력되지 않는다.
4. d는 {'apple','cherry'}
 
'''

```

    {'사과': None}
    

빌트인 함수?
abs()
sqrt() o
map()
..

1. 함수의 인자는 함수 선언시 설정한 값, 인수는 함수 호출시 넘겨주는 값
2. 함수는 오직 하나의 객체만 반환할 수 있다.
3. 함수에서 return을 작성하지 않으면 코드 실행시 오류가 발생한다. x
4. 같은 이름의 함수를 선언하면, 함수 호출시 나중에 선언된 함수가 실행된다. 

'#'


```python
def func(a,b=1, c=2,*args,**kwargs):
    d =sum([n*2 for n in args if n>2])
    e =sum([v*v for k, v in kwargs.items()])
    return a+b+c+d+e

print(func(9,4,2,3,1,7, d=3, e=6))
    #a=9,b=4,c=2, args =3,1,7, d = 6+14  kwargs = {'d':3,'e':6}   e=9+36
    # *내가 가진 모든것을 튜플로 묶어서 그대로 출력하여 args에 갖고있음
    # ** 키와 밸류값을 같이 같고있음, 키와 밸류값을 딕셔너리로 만들어줌 

#
```

    80
    


```python
def fib(n):
    if n == 0 or n==1:
        return 1
    else:
        return fib(n-1) + fib(n-2)
    
print(fib(4))

'''
fib(0)과 fib(1)이 호출되는 횟수는 각각 몇 번인가? 
'''
```


```python
def my_sum(a,b):
    c = a+b
    print(c)
    
result = my_sum(5,8)

#result변수에 들어가있는 값은 None 

#
```

    13
    


```python
a = 1 
def my_func_1():
    a = 5
    my_func_2()

def my_func_2():
    print(a,end='')
    
my_func_1()
print(a)

'''

정의시점이아니라 실행시점에서 정의되어 있는 변수를 봐야 한다. 

a = 1                 ->> a =1이구나
def my_func_1():      ->> 
    a = 5             ->> a=5다         >> (*로인해)a=1로바뀌었다
    my_func_2()       ->> func2 로 가자

def my_func_2():       
    print(a,end='')    ->> * a =1이다  
    
my_func_1() ->> print(a,end='')  ->> a=1 
print(a)    ->> a=1 (맨 밖에 있는 a)


전원정답
'''    


```

    11
    


```python
###################개 념 연 습###################
######여러가지 케이스를 바꿔가면서 보자##########
######안에서는 밖의 값을 조회할 수 있고,#########
######밖에서는 안의 값을 조회할 수 없다는게######
################핵심!@!!!!#######################
a = 1 
def my_func_1():
    a = 5
    my_func_2()
    
    def my_func_3():
        print(a)
    my_func_3

def my_func_2():
    print(a,end='')
    
my_func_1()
print(a)

#
```


```python
###############다른연습#######################
########for, if는 방을 만들지 않는다.#########
for i in [1,2,3]:
    print('hi')
print(i)

def func1():
    print(i)

func1()
```

    hi
    hi
    hi
    3
    3
    


```python
def func(c='5',*args):
    a,c,b = args
    return a+b+c

print(func('3','4','1','2'))

#args = ('4','1','2')
# a= 4 b=2 c=1 

#??????
```


```python
def func(c,b,a):
    return a*b+c 

print(func(2,5,4))
```

    22
    


```python
name = 'hong'
class Person:
    name = 'choi'         #클래스변수공간
    # 얘는 name이 아니라 Person.name이다. / P1.name이다 
                         #클래스 변수공간은 특별하다. 
                         #def greeting에 name이 정의되어있지 않다고 해서 이곳에서 name으로 조회하지 않는다.
                         #다시, Person.name 또는 P1.name으로만 조회 할 수 있다. 
    def greeting(self): # 인스턴스 메소드 
        # name='jung'
        print(name)     #self.name 으로 바꿔서 출력해보자 
p1 = Person()
p1.name = 'kim'     # 인스턴스 변수를 바꾼것이다. 
p1.greeting()

#연습
print(Person.name)
#print(P1.name)
'''
kim이 나오기 위해서는 
    def greeting(self): 
        print(self.name) 


jung이 나오기 위해서는 
    def greeting(self):
        name='jung'
        print(name)

Person.name = 'kang' 
하면 
name = 'choi'가 'kang'으로 바뀐것
'''
p2 =Person()
Person.name = 'kang'    #name = 'choi'가 'kang'으로 바뀜
p2.greeting()


#
```

    hong
    choi
    hong
    


```python
name = 'hong'
class Person:
    population = 0    #클래스 변수 
    def __init__(self,name):
        self.name =name
        Person.population += 1 
    
class Student(Person):
    average = 0     
    
p1 = Person('kim')
p2 = Person('lee')
p3 = Person('soo')
#인스턴스틀이 공통적으로 갖거나, 인스턴스를 뛰어넘어 클래스 수준에서 가져야할 메타변수를 넣는다.
print(p1.population) # 어디에도 population이라는 변수조회가 안된다면, class변수까지 조회하여 불러오도록 하는 기능에 의한 결과
print(p2.population)
```

    3
    3
    


```python
name = 'kim'
def func1():
    name ='kang'
    def func2():
        print(name)
    func2()

func1()

```

    kang
    


```python
name = 'k'
class Person():
    name = 'j'
    def hello(self):
        print(self.name)
        
p1 = Person()
p1.name = 'm'
p1.hello()
```

    m
    


```python
name = 'hong'
class Person:
    name = 'choi'

    def greeting(self): 
        print(self.name)
        
    def hello(self):
        print(name)
    
    def hey(self):
        name = 'jang'
        print(name)
    
    def whatup(self):
        name ='jung'
        print(self.name)  
        
p1 = Person()
p1.name = 'kim'    
p1.greeting()  # 출력1   

print('출력2:',Person.name)   
print('출력3:',p1.name)

p2=Person()
#Person.name = 'kang'    #name = 'choi'가 'kang'으로 바뀜
print('출력4:',Person.name)
p2.name = 'soo'
p2.greeting()  #출력5 
p2.hello()   #출력 6

p3=Person()
p3.hey()  #출력7
print('출력8:', p3.name)
print('출력9:',p3.whatup())
p3.whatup()   #출력9 

```

    kim
    출력2: choi
    출력3: kim
    출력4: choi
    soo
    hong
    jang
    출력8: choi
    choi
    출력9: None
    choi
    


```python
#어트리뷰트에 뭔가를 넣으려면 
#인스턴스.변수 
#어트리뷰트 = 클래스 변수 +인스턴스 변수
#메소드는 클래스 내부공간 안에 있는 
#인스턴스 메소트, 클래스 메소드, 스테틱 메소드.. 
#스테틱 메소드 는 인자로 틀래스 메소드를 넘기지 않는다. 
#함수를 제외한 모든 데이터들 = 어트리뷰트 
# 인스턴스 변수 = 인스턴스 어트리뷰트 
# 클래스 변수 = 클래스 어트리뷰트 
```


```python
my_complex = 3+ 4j
my_list = [1,2,3]
my_dict = {}
'''
에러가 뜨는 것은?
my_complex.real()  x  comp.real로 해야한다
my_list.sort()
my_list.pop()
my_dict.keys()


메소드로서 호출 .메소드() 해야하는 애인지 구분해야 한다. 


'''
```

my_int = 3 
my_int가 정수인지 아는방법?

my_int == 3 
isinstance(int,my_int) x
isinstance(my_int,3) x 
type(my_int) == int  o 


```python
class Person:
    population =0 
    
    def __init__(self,name):
        self.name = name
        Person.population
        
'''
3명 호출 후
population = 3 
'''
```


```python
import copy

list1=[3,'a','b']
list2=[1,2[list1]]
list3= list1[:]
list4= copy.copy(list2)
list5= copy.deepcopy(list2)

'''
list 4[2][0] = 4
print(list2[2][0]) 는 4이다

list4[2] = 5
print(list2[2]) 는 5이다   x

list5[2][1] = 3
print(list2[2][1]) 은 'a'이다 

list1 == list3의 결과는 True이다 

'''
```


```python
def deeepcopy(li):
    #요소를 돌면서 리스트 안에 리스트가 있으면 리스트 카피본을 넣어주고, 아니면 카피만 하겠다. 
    copy_li= []
    for i in len(li):
        if type(li[i]) == list:
            deep_li = []  
            for deep_i in deep_li[i]:
                deep_li.append(deep_li[i])
            copy_li.append(deep_li)
        else:
            copy_li.append(li[i])
    return 

def deeep(l):
    result = []
    for e in l:
        if type(e) == list:
            result.append(e[:])
        else:
            result.append(e)
    return result

list2 is deepcopy(list2)   #False - 위는 딥카피를 하는 함수이다. 
```


```python
보기의 코드를 실행하면 출력되는 결과는 <class'___'>

print(type)

'''
답은 dict
'''
```
